[{"id":0,"href":"/docs/intro-to-tongo/","title":"Introduction","section":"Docs","content":" Introduction to Tongo # Tongo is a confidential payment system for ERC20 tokens on Starknet, providing privacy-preserving transactions while maintaining auditability and compliance features. Built on ElGamal encryption and zero-knowledge proofs, Tongo enables users to transact with hidden amounts while preserving the ability to verify transaction validity.\nWhat Makes Tongo Different # No Trusted Setup # Unlike many ZK systems (Zcash, Tornado Cash), Tongo requires no trusted ceremony. All cryptography is built on the discrete logarithm assumption over the Stark curve, with no hidden trapdoors or setup parameters.\nNative Starknet Integration # Tongo leverages Starknet\u0026rsquo;s native elliptic curve operations, making verification extremely efficient (~120K Cairo steps per transfer) compared to other privacy solutions that require expensive proof verification.\nFlexible Compliance # The protocol supports multiple compliance models:\nGlobal auditor: All transactions encrypted for regulatory oversight Selective disclosure: Optional viewing keys per transaction Ex-post proving: Retroactive transaction disclosure without revealing keys How It Works # 1. Key Generation # Each user generates a keypair \\((x, y = g^x)\\) where \\(g\\) is the Stark curve generator. The public key \\(y\\) serves as their account identifier.\n2. Encrypted Balances # Balances are stored as ElGamal ciphertexts: $$\\text{Enc}[y](b, r) = (g^b y^r, g^r)$$The encryption is additively homomorphic, allowing balance updates without decryption.\n3. Zero-Knowledge Proofs # All operations require proofs built from three primitives:\nPOE (Proof of Exponent): Prove knowledge of discrete logs PED (Pedersen): Prove commitment correctness RAN (Range): Prove values are in valid ranges 4. Transaction Flow # Fund → Transfer → Rollover → Withdraw\nFund: Convert ERC20 to encrypted balance Transfer: Send hidden amounts with ZK proofs Rollover: Claim pending incoming transfers Withdraw: Convert back to standard ERC20 Core Operations # Funding # Convert standard ERC20 tokens to encrypted balances:\nconst fundOp = await account.fund({ amount: 1000n }); await signer.execute([fundOp.approve!, fundOp.toCallData()]); Transfers # Send hidden amounts to other users:\nconst transferOp = account.transfer({ to: recipientPubKey, amount: 100n, viewKeys: [auditorKey] // Optional }); Withdrawals # Convert back to standard ERC20 tokens:\nconst withdrawOp = account.withdraw({ to: starknetAddress, amount: 50n }); Security Model # Privacy Guarantees # Balance confidentiality: Only key holders can decrypt balances Transaction privacy: Transfer amounts are hidden from public view Unlinkability: Transactions don\u0026rsquo;t reveal sender-receiver relationships Integrity Guarantees # No double spending: Range proofs prevent negative balances Conservation: Total supply is preserved (no money creation) Authenticity: Only key owners can spend their balances Assumptions # Discrete Log: Hard to find \\(x\\) given \\(g^x\\) on Stark curve Decisional Diffie-Hellman: ElGamal encryptions are indistinguishable Hash Function: Fiat-Shamir transform uses secure hash Use Cases # Individual Privacy # Personal transactions: Hide payment amounts from public view Salary payments: Confidential payroll systems Merchant payments: Private commercial transactions Institutional Compliance # Regulated environments: Auditor oversight with user privacy Cross-border payments: Compliance with multiple jurisdictions Corporate treasury: Internal transfers with audit trails DeFi Integration # Private AMM trading: Hidden trade sizes Confidential lending: Private collateral amounts DAO treasuries: Private governance token distributions Performance Characteristics # Operation Cairo Steps Time (approx) Fund ~50K \u0026lt;1 second Transfer ~120K 2-5 seconds Withdraw ~80K 1-3 seconds Rollover ~30K \u0026lt;1 second Times include proof generation on modern hardware\nLimitations # Balance Range # Maximum balance: \\(2^{32} - 1\\) (~4.3 billion units) Chosen for efficient brute-force decryption Sufficient for most token denominations Roadmap # Short Term # Bulletproof integration: More efficient range proofs Mobile optimization: Faster proof generation on mobile Multi-token support: Support multiple ERC20s in one contract Medium Term # Layer 2 scaling: Recursive proof aggregation Advanced compliance: Threshold auditing, time-locked viewing DeFi primitives: Native AMM, lending protocols Getting Started # Install the SDK - TypeScript library for application integration Understand Encryption - Learn the cryptographic foundations Explore Transfers - Deep dive into the core protocol Study Proofs - Understand the verification system Configure Auditing - Set up compliance features For developers ready to start building, jump directly to the SDK documentation and begin with the Quick Start examples.\n"},{"id":1,"href":"/docs/encryption/","title":"Encryption System","section":"Docs","content":" Encryption System # Tongo uses ElGamal encryption over elliptic curves to maintain confidential balances while enabling homomorphic operations on-chain.\nElGamal Encryption # Each user\u0026rsquo;s balance is encrypted using a public key derived from their private key. The encryption function is defined as:\n$$\\begin{aligned} \\text{Enc}[y]: [0, b_{\\max}) \\times \\mathbb{F}_p \u0026\\rightarrow G^2 \\\\ \\text{Enc}[y](b,r) \u0026= (L, R) = (g^b y^r, g^r) \\end{aligned}$$Where:\n\\(y = g^x\\) is the user\u0026rsquo;s public key (derived from private key \\(x\\) ) \\(g\\) is the generator of the Stark curve \\(b\\) is the balance amount in the range \\([0, b_{\\max})\\) \\(r\\) is a random blinding factor \\(p\\) is the curve order Additive Homomorphism # The key property that makes Tongo efficient is additive homomorphism. Given two encryptions under the same public key, their product is a valid encryption of the sum:\n$$\\text{Enc}[y](b,r) \\cdot \\text{Enc}[y](b',r') = (g^{b+b'} y^{r+r'}, g^{r+r'}) = \\text{Enc}[y](b+b', r+r')$$This allows the contract to:\nAdd encrypted amounts without decryption Subtract encrypted amounts homomorphically Update balances while maintaining privacy Balance Decryption # To read their balance, a user recovers \\(g^b\\) using their private key \\(x\\) :\n$$g^b = \\frac{L}{R^x} = \\frac{g^b y^r}{(g^r)^x} = \\frac{g^b (g^x)^r}{g^{rx}} = g^b$$Since \\(b\\) is bounded by \\([0, 2^{32})\\) , the discrete logarithm \\(b\\) can be computed efficiently through:\nBrute force: Iterate \\(g^i\\) for \\(i = 0, 1, 2, ...\\) until matching \\(g^b\\) Baby-step Giant-step: More efficient \\(O(\\sqrt{n})\\) algorithm Pollard\u0026rsquo;s rho: Probabilistic algorithm with similar complexity A naïve JavaScript implementation can decrypt ~100k units per second, while optimized algorithms handle the full 32-bit range much faster.\nStorage Architecture # The Tongo contract maintains multiple encrypted representations of each balance:\nPrimary Balances # balance: Current encrypted balance using user\u0026rsquo;s public key audit_balance: Same balance encrypted for global auditor\u0026rsquo;s key pending: Buffer for incoming transfers (anti-spam protection) Recovery Balance # sym_balance: Symmetrically encrypted balance for fast recovery The symmetric encryption uses a key derived from the user\u0026rsquo;s private key, allowing instant balance recovery without discrete log computation. This is particularly useful for mobile wallets and cross-device synchronization.\n**Implementation Note**: The `sym_balance` is not cryptographically enforced by the protocol since there's no way to prove the user provided the correct symmetric ciphertext. It's purely a convenience feature. Security Properties # Computational Assumptions # Discrete Log Problem: Hard to find \\(x\\) given \\(g^x\\) Decisional Diffie-Hellman: Hard to distinguish random group elements from valid encryptions Practical Security # 32-bit range: Balances limited to \\([0, 2^{32})\\) for efficient decryption Random blinding: Each encryption uses fresh randomness Curve security: Relies on Stark curve (ECDSA-256 security level) Privacy Guarantees # Balance confidentiality: Only the key holder can decrypt Transaction privacy: Transfer amounts remain hidden Unlinkability: Encrypted balances don\u0026rsquo;t reveal relationships Example: Fund Operation # When a user funds their account with amount \\(b\\) :\nPublic inputs: \\(b\\) (revealed in ERC20 transfer), \\(y\\) (user\u0026rsquo;s public key) Encryption: \\(\\text{Enc}[y](b, 1) = (g^b y, g)\\) Storage: Add to user\u0026rsquo;s encrypted balance homomorphically Note that \\(r = 1\\) is used for funding since the amount \\(b\\) is already public in the ERC20 transaction.\n// Cairo implementation (simplified) let funded_cipher = CipherBalance { CL: (curve_ops::multiply(G, b) + curve_ops::multiply(y, 1)), CR: curve_ops::multiply(G, 1) }; // Add to existing balance homomorphically balance = cipher_add(balance, funded_cipher); The homomorphic addition is performed point-wise:\n$$L_{\\text{new}} = L_{\\text{old}} \\cdot L_{\\text{fund}}$$ $$R_{\\text{new}} = R_{\\text{old}} \\cdot R_{\\text{fund}}$$This mathematical elegance allows Tongo to update balances without ever revealing the underlying amounts, forming the foundation for all confidential operations in the protocol.\n"},{"id":2,"href":"/docs/transfer/","title":"Transfer Protocol","section":"Docs","content":" Transfer Protocol # The transfer operation is the core of Tongo\u0026rsquo;s confidential payment system, allowing users to send encrypted amounts while proving transaction validity through zero-knowledge proofs.\nTransfer Overview # When a user (sender) with public key \\(y_s\\) and balance \\(b_0\\) wants to transfer amount \\(b \u003c b_0\\) to a receiver with public key \\(y_r\\) , they must:\nCreate encryptions for sender, receiver, and auditor Generate ZK proofs to validate the transaction Submit transaction with ciphertexts and proofs The key insight is that balances are updated homomorphically without revealing the transfer amount.\nMulti-Party Encryption # The sender creates (at least) three encryptions of the same amount \\(b\\) using the same blinding factor \\(r\\) :\nSender Encryption # $$(\\mathit{L_s}, \\mathit{R_s}) = \\text{Enc}[y_s](b, r) = (g^b y_s^r, g^r)$$This will be subtracted from the sender\u0026rsquo;s balance.\nReceiver Encryption # $$(\\mathit{L_r}, \\mathit{R_r}) = \\text{Enc}[y_r](b, r) = (g^b y_r^r, g^r)$$This will be added to the receiver\u0026rsquo;s pending balance.\nAuditor Encryption # $$(\\mathit{L_a}, \\mathit{R_a}) = \\text{Enc}[y_a](b, r) = (g^b y_a^r, g^r)$$This provides an audit trail for compliance without revealing amounts.\n**Security Note**: Using the same blinding factor \\(r\\) across all encryptions is safe for single-recipient transfers but could enable insider attacks in multi-recipient schemes. Tongo mitigates this by design. Transaction Structure # struct Transfer { from: PubKey, // Sender\u0026#39;s public key to: PubKey, // Receiver\u0026#39;s public key L: StarkPoint, // L_s (sender encryption left) L_rec: StarkPoint, // L_r (receiver encryption left) L_audit: StarkPoint, // L_a (auditor encryption left) L_opt: Option\u0026lt;Array\u0026lt;(PubKey, StarkPoint)\u0026gt;\u0026gt;, // Additional viewing keys R: StarkPoint, // Shared R component proof: ProofOfTransfer, // ZK proof bundle } Required Zero-Knowledge Proofs # The sender must provide a comprehensive proof \\(\\pi_{\\text{transfer}}\\) demonstrating:\n1. Ownership Proof (POE) # Prove knowledge of private key \\(x\\) such that \\(y_s = g^x\\) : $$\\pi_{\\text{ownership}}: \\{(g, y_s; x) : y_s = g^x\\}$$ 2. Blinding Factor Proof (POE) # Prove knowledge of (r) such that (R = g^r): $$\\pi_{\\text{blinding}}: \\{(g, R; r) : R = g^r\\}$$ 3. Encryption Validity (PED) # Prove that (L_s) is correctly formed: $$\\pi_{\\text{sender}}: \\{(g, y_s, L_s; b, r) : L_s = g^b y_s^r\\}$$Prove that (L_r) uses the same (b) and (r): $$\\pi_{\\text{receiver}}: \\{(g, y_r, L_r; b, r) : L_r = g^b y_r^r\\}$$Prove that (L_a) uses the same (b) and (r): $$\\pi_{\\text{auditor}}: \\{(g, y_a, L_a; b, r) : L_a = g^b y_a^r\\}$$ 4. Range Proofs (RAN) # Prove the transfer amount is positive: $$\\pi_{\\text{amount}}: \\{(g, h, V_b; b, r_b) : V_b = g^b h^{r_b} \\land b \\in [0, b_{\\max})\\}$$Prove the remaining balance is non-negative: $$\\pi_{\\text{remaining}}: \\{(g, h, V_{b'}; b', r_{b'}) : V_{b'} = g^{b'} h^{r_{b'}} \\land b' \\in [0, b_{\\max})\\}$$Where (b\u0026rsquo; = b_0 - b) is the sender\u0026rsquo;s balance after the transfer.\nComplete Transfer Proof # The full proof statement combines all requirements:\n$$\\begin{aligned} \\pi_{\\text{transfer}}: \\{\u0026(g, y_s, y_r, L_0, R_0, L_s, L_r, R; x, b, b', r) : \\\\ \u0026y_s = g^x \\\\ \u0026\\land R = g^r \\\\ \u0026\\land L_s = g^b y_s^r \\\\ \u0026\\land L_r = g^b y_r^r \\\\ \u0026\\land b \\in [0, b_{\\max}) \\\\ \u0026\\land L_0/L_s = g^{b'}(R_0/R)^x \\\\ \u0026\\land b' \\in [0, b_{\\max})\\} \\end{aligned}$$Where ((L_0, R_0)) represents the sender\u0026rsquo;s current encrypted balance.\nBalance Updates # Upon successful proof verification, the contract performs homomorphic updates:\nSender Balance Update # // Subtract transfer amount from sender new_sender_balance = cipher_subtract(old_sender_balance, sender_cipher); Mathematically:\n$$(L_0, R_0) \\div (L_s, R_s) = (L_0/L_s, R_0/R_s)$$ Receiver Pending Update # // Add transfer amount to receiver\u0026#39;s pending balance new_pending_balance = cipher_add(old_pending_balance, receiver_cipher); Mathematically:\n$$(L_p, R_p) \\cdot (L_r, R_r) = (L_p \\cdot L_r, R_p \\cdot R_r)$$ Anti-Spam Protection # Transfers are added to the receiver\u0026rsquo;s pending balance rather than their main balance to prevent spam attacks. This design:\nPrevents balance corruption: Malicious actors can\u0026rsquo;t modify someone\u0026rsquo;s main balance Enables atomic proofs: Senders prove against a known balance state Requires explicit rollover: Receivers must claim pending transfers The receiver later calls rollover() to merge pending transfers into their main balance.\nExample Flow # // 1. Sender creates transfer const transfer = await sender.transfer({ to: receiverPubKey, amount: 100n, viewKeys: [auditorPubKey] // Optional additional viewers }); // 2. Submit to contract await signer.execute(transfer.toCallData()); // 3. Receiver claims pending balance const rollover = await receiver.rollover(); await signer.execute(rollover.toCallData()); Security Considerations # Replay Protection # Each proof includes the sender\u0026rsquo;s nonce and contract address in the Fiat-Shamir challenge computation, preventing proof reuse.\nRange Proof Security # The 32-bit range proofs ensure:\nTransfer amounts are non-negative Remaining balances don\u0026rsquo;t underflow No \u0026ldquo;money creation\u0026rdquo; attacks Homomorphic Security # The ElGamal encryption scheme maintains semantic security even under homomorphic operations, ensuring transferred amounts remain confidential.\nGas Optimization # Transfer verification costs approximately 120K Cairo steps, making it efficient compared to other ZK verification schemes:\nComponent Cairo Steps Percentage POE proofs ~30K 25% PED proofs ~40K 33% Range proofs ~45K 38% Contract logic ~5K 4% Future optimizations target reducing range proof costs through Bulletproof integration and more efficient bit decomposition techniques.\n"},{"id":3,"href":"/docs/auditor/","title":"Auditing \u0026 Compliance","section":"Docs","content":" Auditing \u0026amp; Compliance # Tongo provides flexible auditing mechanisms that enable compliance without sacrificing user privacy. Through viewing keys and ex-post proving, regulators can verify transaction details while preserving confidentiality for all other parties.\nGlobal Auditor # Concept # The Tongo contract can designate a global auditor with public key (y_a). All transfers are automatically encrypted for this auditor, providing a comprehensive audit trail without revealing amounts on-chain.\nAuditor Encryption # For every transfer of amount (b), the sender creates three encryptions:\nSender: ((L_s, R) = \\text{Enc}[y_s](b, r)) - subtracted from balance Receiver: ((L_r, R) = \\text{Enc}[y_r](b, r)) - added to pending Auditor: ((L_a, R) = \\text{Enc}[y_a](b, r)) - stored for audit All three use the same blinding factor (r), proven via Pedersen commitment proofs.\nMulti-Signature Auditing # For enhanced security, auditor keys can be distributed across multiple parties:\n$$y_a = g^{a_1 + a_2} = g^{a_1} \\cdot g^{a_2} = y_{a_1} \\cdot y_{a_2}$$Individual auditors can compute partial decryptions:\nAuditor 1: (R^{a_1} = (g^r)^{a_1}) Auditor 2: (R^{a_2} = (g^r)^{a_2}) The balance is recovered by combining: (g^b = L_a / (R^{a_1} \\cdot R^{a_2}))\nThis prevents any single auditor from unilaterally accessing transaction data.\nViewing Keys # Selective Disclosure # Users can optionally encrypt transfers for additional viewing keys beyond the global auditor:\nstruct Transfer { // ... other fields ... L_opt: Option\u0026lt;Array\u0026lt;(PubKey, StarkPoint)\u0026gt;\u0026gt;, // Additional viewing keys } Each viewing key ((y_v, L_v)) represents: $$L_v = g^b y_v^r$$The sender proves each additional encryption is correctly formed using Pedersen commitment proofs.\nUse Cases # Compliance officers: Institutional oversight Tax authorities: Jurisdiction-specific reporting Internal auditing: Corporate governance Dispute resolution: Escrow and arbitration Privacy-Preserving Architecture # Viewing keys maintain privacy by:\nOnly revealing amounts to authorized parties Not exposing transaction relationships on-chain Allowing granular access control per transaction Ex-Post Proving # Motivation # After a transfer is completed, participants may need to prove transaction details to third parties without revealing their private keys. Ex-post proving enables this through cryptographic proofs.\nProtocol # Consider a completed transfer with ciphertext ((TL, TR) = (g^{b_0} y^{r_0}, g^{r_0})). To prove the transfer amount to a third party with public key (\\bar{y}):\n1. Revelation Phase # The sender creates new encryptions of the same amount:\nSender encryption: ((L, R) = \\text{Enc}[y](b, r)) Third-party encryption: ((\\bar{L}, R) = \\text{Enc}[\\bar{y}](b, r)) 2. Consistency Proof # The sender proves the new encryptions contain the same amount as the original transfer:\n$$\\frac{TL}{L} = \\left(\\frac{TR}{R}\\right)^x$$This equality holds if and only if (b_0 = b) (the amounts match).\n3. Required Proofs # The complete ex-post proof (\\pi_{\\text{expost}}) demonstrates:\nOwnership: Knowledge of (x) such that (y = g^x) (POE) Blinding: Knowledge of (r) such that (R = g^r) (POE) Sender encryption: (L = g^b y^r) (PED) Third-party encryption: (\\bar{L} = g^b \\bar{y}^r) (PED) Consistency: (TL/L = (TR/R)^x) (POE) Mathematical Foundation # The consistency check works because: $$\\frac{TL}{L} = \\frac{g^{b_0} y^{r_0}}{g^b y^r} = g^{b_0-b} y^{r_0-r}$$$$\\left(\\frac{TR}{R}\\right)^x = \\left(\\frac{g^{r_0}}{g^r}\\right)^x = g^{(r_0-r)x} = y^{r_0-r}$$These are equal only when (b_0 = b), proving amount consistency.\nOff-Chain Verification # Ex-post proofs require no on-chain interaction:\nTransaction data is retrieved from chain state Proofs are generated and verified off-chain Only requires the original transaction hash as reference Regulatory Compliance # AML/KYC Integration # Tongo supports various compliance frameworks:\nReal-Time Monitoring # Global auditor receives all transaction encryptions Automated threshold detection (encrypted amounts) Pattern analysis on transaction graphs Selective Disclosure # Users can voluntarily encrypt for compliance officers Jurisdiction-specific reporting requirements Time-limited viewing key access Retroactive Investigation # Ex-post proving enables transaction reconstruction User cooperation required for private key revelation Court-ordered disclosure mechanisms Privacy-Compliance Balance # Transparent Model # Configuration: Global auditor sees all transactions\nPrivacy: High (amounts hidden from public) Compliance: High (full audit trail) Use case: Regulated institutional environments Selective Model # Configuration: Optional viewing keys per transaction\nPrivacy: Very High (user-controlled disclosure) Compliance: Medium (voluntary cooperation) Use case: Consumer applications with optional compliance Hybrid Model # Configuration: Global auditor + optional viewing keys\nPrivacy: High (amounts hidden, relationships visible to auditor) Compliance: Very High (comprehensive monitoring) Use case: Banking and financial services Technical Implementation # // Configure global auditor during deployment const tongoContract = await deployer.deploy(\u0026#34;Tongo\u0026#34;, { globalAuditor: auditorPublicKey, // ... other parameters }); // Transfer with additional viewing keys const transfer = await sender.transfer({ to: receiverPubKey, amount: 1000n, viewKeys: [ complianceOfficerKey, taxAuthorityKey ] }); // Ex-post proving to regulator const exPostProof = await sender.proveTransfer( transferTxHash, regulatorPubKey ); Legal Framework Integration # GDPR compliance: User controls data sharing through viewing keys Financial regulations: Automated reporting via auditor decryption Privacy laws: Cryptographic guarantees prevent unauthorized access Audit requirements: Immutable transaction logs with selective disclosure Advanced Features # Threshold Auditing # Multiple auditors with threshold decryption: $$y_a = \\sum_{i=1}^n w_i \\cdot y_{a_i}$$Where (w_i) are threshold weights and (t) out of (n) auditors are required for decryption.\nTime-Limited Access # Viewing keys can include temporal constraints:\nProof includes timestamp validation Access expires after specified duration Prevents indefinite surveillance capabilities Zero-Knowledge Compliance # Prove compliance properties without revealing amounts:\nRange compliance: Prove transfer amount below threshold Velocity limits: Prove cumulative amounts within bounds Whitelist compliance: Prove recipient authorization These advanced features demonstrate Tongo\u0026rsquo;s flexibility in balancing privacy and regulatory requirements across diverse jurisdictions and use cases.\n"},{"id":4,"href":"/docs/sdk/","title":"SDK Documentation","section":"Docs","content":" SDK Documentation # The Tongo TypeScript SDK provides a comprehensive interface for building confidential payment applications on Starknet. It handles key management, encryption, proof generation, and transaction serialization.\nInstallation # npm install tongo-sdk # or yarn add tongo-sdk Architecture # The SDK consists of two main components:\nStarknet Homomorphic Encryption (SHE) # Low-level cryptographic primitives for ElGamal encryption and ZK proof generation over the Stark curve.\nTongo SDK # High-level application interface that abstracts away cryptographic complexity and provides a clean API for wallet integrations.\nQuick Start # Basic Usage # import { Account, utils } from \u0026#34;tongo-sdk\u0026#34;; // Generate a new private key const secret = utils.generatePrivateKey(); // Create account instance const account = new Account(secret, \u0026#34;0x123...tongoContractAddress\u0026#34;); console.log(\u0026#34;Public Key:\u0026#34;, account.prettyPublicKey()); // Output: Um6QEVHZaXkii8hWzayJf6PBWrJCTuJomAst75Zmy12 Fund Account # // Fund account with 1000 tokens const fundOperation = await account.fund({ amount: 1000n }); // Execute with any Starknet signer (includes approval + fund) const tx = await signer.execute([fundOperation.approve!, fundOperation.toCallData()]); await provider.waitForTransaction(tx.transaction_hash); Transfer Tokens # // Create confidential transfer const transferOperation = account.transfer({ to: receiverPubKey, amount: 100n, viewKeys: [auditorPubKey] // Optional viewing keys }); // Submit transaction const callData = transferOperation.toCallData(); const tx = await signer.execute([callData]); Check Balance # // Get encrypted balance const encryptedBalance = account.balance(); // Decrypt balance (brute force in range) const actualBalance = account.decryptBalance(0n, 1000000n); console.log(\u0026#34;Balance:\u0026#34;, actualBalance); API Reference # Account Class # The main abstraction for interacting with Tongo accounts.\nConstructor # constructor( secret: bigint | Uint8Array, tongoAddress: string, options?: { signer?: Signer, provider?: Provider } ) Parameters:\nsecret: Private key as bigint or byte array tongoAddress: Deployed Tongo contract address options.signer: Optional Starknet signer for automatic transaction submission options.provider: Optional Starknet provider for balance queries Key Management # // Get public key as coordinate pair publicKey(): [bigint, bigint] // Get base58-encoded public key string prettyPublicKey(): string // Get current account nonce nonce(): Promise\u0026lt;number\u0026gt; Balance Operations # // Get encrypted balance from contract balance(): Promise\u0026lt;CipherBalance\u0026gt; // Get encrypted pending balance pending(): Promise\u0026lt;CipherBalance\u0026gt; // Decrypt balance in specified range decryptBalance(lowBound: bigint, highBound: bigint): Promise\u0026lt;bigint\u0026gt; // Decrypt pending balance in specified range decryptPending(lowBound: bigint, highBound: bigint): Promise\u0026lt;bigint\u0026gt; Transaction Operations # // Fund account with ERC20 tokens fund( amount: bigint, options: { approval: boolean } ): FundOperation // Transfer tokens to another account transfer(params: { to: PubKey | string, amount: bigint, viewKeys?: (PubKey | string)[] }, options?: { pending?: [bigint, bigint] // Manual pending balance override }): TransferOperation // Transfer with relayer fee transferWithFee(params: { to: PubKey | string, amount: bigint, feeReceiver: PubKey | string, feeAmount: bigint, viewKeys?: (PubKey | string)[] }): TransferWithFeeOperation // Merge pending transfers into main balance rollover(): RolloverOperation // Withdraw tokens back to ERC20 withdraw(params: { to: string, // Starknet address amount: bigint }): WithdrawOperation Operation Objects # All transaction methods return operation objects that can be serialized to transaction data:\nFundOperation # interface FundOperation { // Serialize to Starknet transaction calls toCallData(): Call[] // Get proof components getProof(): ProofOfOwnership // Get operation metadata getMetadata(): { amount: bigint, recipient: PubKey } } TransferOperation # interface TransferOperation { // Serialize to Starknet transaction calls toCallData(): Call[] // Get all proof components getProof(): ProofOfTransfer // Get encrypted components getCiphertexts(): { sender: CipherBalance, receiver: CipherBalance, auditor?: CipherBalance, viewKeys: Array\u0026lt;{ pubkey: PubKey, cipher: StarkPoint }\u0026gt; } // Get operation metadata getMetadata(): { from: PubKey, to: PubKey, amount: bigint, viewKeys: PubKey[] } } "},{"id":5,"href":"/docs/contracts/","title":"Cairo Contracts","section":"Docs","content":" Cairo Contracts # The Tongo protocol is implemented as a Cairo smart contract on Starknet, leveraging native elliptic curve operations for efficient zero-knowledge proof verification.\nContract Architecture # Core Contract (main.cairo) # The main Tongo contract implements the ITongo interface and manages all confidential payment operations:\n#[starknet::interface] pub trait ITongo\u0026lt;TContractState\u0026gt; { fn fund(ref self: TContractState, fund: Fund); fn rollover(ref self: TContractState, rollover: Rollover); fn withdraw_all(ref self: TContractState, withdraw_all: WithdrawAll); fn withdraw(ref self: TContractState, withdraw: Withdraw); fn transfer(ref self: TContractState, transfer: Transfer); // State queries fn get_balance(self: @TContractState, y: PubKey) -\u0026gt; CipherBalance; fn get_audit(self: @TContractState, y: PubKey) -\u0026gt; CipherBalance; fn get_pending(self: @TContractState, y: PubKey) -\u0026gt; CipherBalance; fn get_nonce(self: @TContractState, y: PubKey) -\u0026gt; u64; fn get_state(self: @TContractState, y: PubKey) -\u0026gt; State; fn ERC20(self: @TContractState) -\u0026gt; ContractAddress; } Storage Structure # #[storage] struct Storage { balance: Map\u0026lt;PubKey, CipherBalance\u0026gt;, // Main encrypted balances audit_balance: Map\u0026lt;PubKey, CipherBalance\u0026gt;, // Auditor encrypted copies pending: Map\u0026lt;PubKey, CipherBalance\u0026gt;, // Incoming transfer buffer ae_balance: Map\u0026lt;PubKey, AEBalance\u0026gt;, // Fast decrypt hints ae_audit_balance: Map\u0026lt;PubKey, AEBalance\u0026gt;, // Fast decrypt audit hints nonce: Map\u0026lt;PubKey, u64\u0026gt;, // Replay protection } Events # The contract emits events for all operations to enable off-chain monitoring:\n#[derive(Drop, starknet::Event)] struct TransferEvent { from: PubKey, to: PubKey, nonce: u64 } #[derive(Drop, starknet::Event)] struct FundEvent { to: PubKey, amount: felt252, nonce: u64 } #[derive(Drop, starknet::Event)] struct WithdrawEvent { from: PubKey, to: ContractAddress, amount: felt252, nonce: u64 } #[derive(Drop, starknet::Event)] struct RolloverEvent { account: PubKey, nonce: u64 } Data Structures # Core Types # // Public key as elliptic curve point struct PubKey { x: felt252, y: felt252 } // ElGamal ciphertext struct CipherBalance { CL: StarkPoint, // g^b * y^r (left component) CR: StarkPoint // g^r (right component) } // Authenticated encryption balance struct AEBalance { ciphertext: u512, nonce: u256 } // Complete account state struct State { balance: CipherBalance, pending: CipherBalance, audit: CipherBalance, nonce: u64, ae_balance: AEBalance, ae_audit_balance: AEBalance } Operation Structures # struct Fund { to: PubKey, amount: felt252, ae_hints: AEHints, proof: ProofOfFund } struct Transfer { from: PubKey, to: PubKey, L: StarkPoint, // Sender encryption left component L_bar: StarkPoint, // Receiver encryption left component L_audit: StarkPoint, // Auditor encryption left component R: StarkPoint, // Shared right component ae_hints: AEHints, proof: ProofOfTransfer } struct Withdraw { from: PubKey, amount: felt252, to: ContractAddress, // Starknet address to receive ERC20 ae_hints: AEHints, proof: ProofOfWithdraw } Verification System # Proof Verifier (verifier/) # The contract includes a sophisticated zero-knowledge proof verification system:\nverifier.cairo - Main verification logic # verify_fund(): Validates funding proofs (POE) verify_transfer(): Validates transfer proofs (POE + PED + RAN) verify_withdraw(): Validates withdrawal proofs (POE + RAN) verify_range(): Bit-decomposition range proofs verify_pedersen(): Pedersen commitment proofs utils.cairo - Cryptographic utilities # Point arithmetic operations Hash computations for Fiat-Shamir Curve parameter constants structs.cairo - Proof data structures # struct ProofOfFund { Ax: StarkPoint, sx: felt252 } struct ProofOfTransfer { ownership: ProofOfOwnership, blinding: ProofOfOwnership, sender_ped: ProofOfPedersen, receiver_ped: ProofOfPedersen, audit_ped: ProofOfPedersen, amount_range: ProofOfRange, remaining_range: ProofOfRange } Operations # 1. Fund Operation # Converts ERC20 tokens to encrypted balances:\nfn fund(ref self: TContractState, fund: Fund) { // Verify proof of ownership verify_fund(fund.proof, fund.to, fund.amount); // Transfer ERC20 from user (implementation details vary) // let erc20 = IERC20Dispatcher { contract_address: erc20_address }; // erc20.transfer_from(get_caller_address(), get_contract_address(), fund.amount.into()); // Create encrypted balance let cipher = encrypt_balance(fund.amount, fund.to); // Update storage self.balance.write(fund.to, cipher_add(self.balance.read(fund.to), cipher)); self.nonce.write(fund.to, self.nonce.read(fund.to) + 1); } 2. Transfer Operation # Performs confidential transfers between accounts:\nfn transfer(ref self: TContractState, transfer: Transfer) { // Verify comprehensive transfer proof verify_transfer(transfer.proof, /* public inputs */); // Update sender balance (subtract) let sender_cipher = CipherBalance { L: transfer.L, R: transfer.R }; let old_balance = self.balance.read(transfer.from); self.balance.write(transfer.from, cipher_subtract(old_balance, sender_cipher)); // Update receiver pending (add) let receiver_cipher = CipherBalance { L: transfer.L_rec, R: transfer.R }; let old_pending = self.pending.read(transfer.to); self.pending.write(transfer.to, cipher_add(old_pending, receiver_cipher)); // Update auditor balance let audit_cipher = CipherBalance { L: transfer.L_audit, R: transfer.R }; let old_audit = self.audit_balance.read(transfer.from); self.audit_balance.write(transfer.from, cipher_subtract(old_audit, audit_cipher)); } 3. Rollover Operation # Merges pending transfers into main balance:\nfn rollover(ref self: TContractState, rollover: Rollover) { // Verify ownership verify_ownership(rollover.proof, rollover.to); // Move pending to balance let pending = self.pending.read(rollover.to); let balance = self.balance.read(rollover.to); self.balance.write(rollover.to, cipher_add(balance, pending)); // Clear pending self.pending.write(rollover.to, CipherBalance { L: zero_point(), R: zero_point() }); } Security Features # Anti-Spam Protection # Pending balance system: Incoming transfers go to separate pending storage Explicit rollover: Users must claim pending transfers Nonce protection: Prevents replay attacks Range Proof Security # 32-bit decomposition: Ensures amounts are in valid range [0, 2³²) Bit verification: Each bit proven to be 0 or 1 using OR proofs Overflow prevention: Prevents negative balances and money creation Cryptographic Guarantees # Discrete log assumption: Security based on Stark curve Fiat-Shamir: Makes interactive proofs non-interactive Context binding: Proofs tied to specific transactions Deployment # Configuration # // Contract constructor fn constructor( ref self: ContractState, strk_address: ContractAddress, // ERC20 token to wrap view: PubKey // Global auditor public key ) { self.strk_address.write(strk_address); self.view.write(view); } Dependencies # Starknet Foundry: Testing framework Custom ERC20: Token implementation for STRK Cairo 2.8.4: Contract language version Gas Optimization # The contract is optimized for Starknet\u0026rsquo;s Cairo VM:\nOperation Cairo Steps Optimization Fund ~50K Single POE proof Transfer ~120K Efficient range proofs Withdraw ~80K Minimized operations Rollover ~30K Simple balance addition Testing # Comprehensive test suite covers:\nUnit tests: Individual function verification Integration tests: Full operation flows Proof tests: ZK proof generation and verification Edge cases: Error conditions and boundary values # Run all tests scarb test # Deploy to testnet scarb run deploy_local The Cairo implementation provides a secure, efficient foundation for confidential payments on Starknet.\n"},{"id":6,"href":"/docs/she/","title":"SHE Library","section":"Docs","content":" Starknet Homomorphic Encryption (SHE) # The SHE library (she-js) provides low-level cryptographic primitives for ElGamal encryption and zero-knowledge proof generation over the Stark elliptic curve. It serves as the foundation for all cryptographic operations in Tongo.\nInstallation # npm install she-js Core Concepts # Elliptic Curve Setup # SHE operates over the Stark curve with carefully chosen generators:\nimport { g, h, view, auditor_key } from \u0026#39;she-js\u0026#39;; // Primary generator (standard Stark curve generator) const g: ProjectivePoint; // Secondary generator (derived from π digits - nothing up my sleeve) const h: ProjectivePoint; // Global auditor public key const view: ProjectivePoint; // Global auditor secret key (for testing) const auditor_key: bigint; ElGamal Encryption # Basic Encryption # import { cipher_balance, decipher_balance } from \u0026#39;she-js\u0026#39;; // Encrypt a balance amount function cipher_balance( amount: bigint, // Amount to encrypt publicKey: ProjectivePoint, // Recipient\u0026#39;s public key randomness?: bigint // Optional blinding factor ): CipherBalance; // Example const pubkey = g.multiply(secretKey); const encrypted = cipher_balance(1000n, pubkey); console.log(encrypted); // { L: Point, R: Point } Decryption # // Decrypt a ciphertext (requires brute force for amount) function decipher_balance( cipher: CipherBalance, secretKey: bigint, maxAmount: bigint = 1000000n ): bigint; // Example const amount = decipher_balance(encrypted, secretKey, 1000000n); console.log(amount); // 1000n Homomorphic Operations # // Add two encrypted balances function cipher_add( cipher1: CipherBalance, cipher2: CipherBalance ): CipherBalance; // Subtract encrypted balances function cipher_subtract( cipher1: CipherBalance, cipher2: CipherBalance ): CipherBalance; // Example: encrypted arithmetic const encrypted1 = cipher_balance(100n, pubkey); const encrypted2 = cipher_balance(50n, pubkey); const sum = cipher_add(encrypted1, encrypted2); const result = decipher_balance(sum, secretKey); // 150n Zero-Knowledge Proofs # Proof of Exponent (POE) # Proves knowledge of discrete logarithm \\\\(x\\\\) such that \\\\(y = g^x\\\\):\nimport { prove_fund, verify_fund } from \u0026#39;she-js\u0026#39;; // Generate proof of ownership for funding function prove_fund( secret: bigint, // Private key publicKey: ProjectivePoint, // Corresponding public key amount: bigint, // Amount being funded nonce: bigint // Replay protection ): ProofOfOwnership; // Verify the proof function verify_fund( proof: ProofOfOwnership, publicKey: ProjectivePoint, amount: bigint, nonce: bigint ): boolean; // Example const secret = 12345n; const pubkey = g.multiply(secret); const proof = prove_fund(secret, pubkey, 1000n, 1n); const valid = verify_fund(proof, pubkey, 1000n, 1n); // true Transfer Proofs # Complex proofs for confidential transfers:\nimport { prove_transfer, verify_transfer } from \u0026#39;she-js\u0026#39;; function prove_transfer( senderSecret: bigint, senderPubkey: ProjectivePoint, receiverPubkey: ProjectivePoint, amount: bigint, currentBalance: bigint, randomness: bigint, nonce: bigint ): ProofOfTransfer; function verify_transfer( proof: ProofOfTransfer, senderPubkey: ProjectivePoint, receiverPubkey: ProjectivePoint, senderCipher: CipherBalance, receiverCipher: CipherBalance, auditCipher: CipherBalance, remainingCipher: CipherBalance, nonce: bigint ): boolean; Range Proofs # Proves values lie in valid ranges using bit decomposition:\nimport { prove_range, verify_range } from \u0026#39;she-js\u0026#39;; function prove_range( value: bigint, randomness: bigint, commitment: ProjectivePoint, bitLength: number = 32 ): ProofOfRange; function verify_range( proof: ProofOfRange, commitment: ProjectivePoint, bitLength: number = 32 ): boolean; // Example: prove amount is in [0, 2^32) const value = 1000n; const r = random_scalar(); const commitment = g.multiply(value).add(h.multiply(r)); const proof = prove_range(value, r, commitment); const valid = verify_range(proof, commitment); // true Withdrawal Proofs # import { prove_withdraw, verify_withdraw, prove_withdraw_all, verify_withdraw_all } from \u0026#39;she-js\u0026#39;; // Partial withdrawal function prove_withdraw( secret: bigint, currentBalance: bigint, withdrawAmount: bigint, randomness: bigint, nonce: bigint ): ProofOfWithdraw; // Full withdrawal (simpler proof) function prove_withdraw_all( secret: bigint, balance: CipherBalance, amount: bigint, nonce: bigint ): ProofOfWithdrawAll; Audit System # Ex-Post Proofs # Generate proofs for retroactive transaction disclosure:\nimport { prove_expost, verify_expost } from \u0026#39;she-js\u0026#39;; function prove_expost( senderSecret: bigint, amount: bigint, randomness: bigint, originalCipher: CipherBalance, disclosureKey: ProjectivePoint ): ExPostProof; function verify_expost( proof: ExPostProof, senderPubkey: ProjectivePoint, disclosureKey: ProjectivePoint, originalCipher: CipherBalance, disclosedCipher: CipherBalance, disclosureAmount: CipherBalance ): bigint; // Returns disclosed amount // Example: prove transfer amount to auditor const transferCipher = { L: Point1, R: Point2 }; const auditorKey = g.multiply(auditorSecret); const proof = prove_expost(senderSecret, amount, r, transferCipher, auditorKey); const disclosedAmount = verify_expost(proof, senderPubkey, auditorKey, transferCipher, newCipher, amountCipher); Utility Functions # Key Management # import { random_scalar, point_from_hex, point_to_hex } from \u0026#39;she-js\u0026#39;; // Generate cryptographically secure random scalar const secret = random_scalar(); // Derive public key const pubkey = g.multiply(secret); // Serialize/deserialize points const hexString = point_to_hex(pubkey); const recovered = point_from_hex(hexString); Hash Functions # import { hash_to_scalar, hash_points } from \u0026#39;she-js\u0026#39;; // Hash arbitrary data to scalar (for challenges) const challenge = hash_to_scalar([point1, point2, nonce]); // Hash multiple points together const combined = hash_points([pubkey1, pubkey2, commitment]); Advanced Features # Batch Operations # // Encrypt multiple amounts efficiently function cipher_batch( amounts: bigint[], publicKeys: ProjectivePoint[], randomness?: bigint[] ): CipherBalance[]; // Verify multiple proofs together function verify_batch_fund( proofs: ProofOfOwnership[], publicKeys: ProjectivePoint[], amounts: bigint[], nonces: bigint[] ): boolean; Custom Generators # // Use custom generators for specific applications import { SHE } from \u0026#39;she-js\u0026#39;; const customSHE = new SHE({ generator: customG, secondGenerator: customH, curve: \u0026#39;stark\u0026#39; // or custom curve parameters }); Performance Considerations # Optimization Tips # // Cache expensive computations const precomputed = { gTable: g.precomputeWindow(8), // Precompute for faster scalar multiplication hTable: h.precomputeWindow(8) }; // Use batch verification when possible const allValid = verify_batch_fund(proofs, pubkeys, amounts, nonces); // Limit brute force range for decryption const amount = decipher_balance(cipher, secret, 100000n); // Reasonable upper bound Memory Management # // Clean up large proof objects after use function cleanupProof(proof: ProofOfTransfer) { // Proof objects can be large (~32KB) // Consider cleanup in memory-constrained environments proof = null; } Error Handling # import { SHEError, ProofError, DecryptionError } from \u0026#39;she-js\u0026#39;; try { const proof = prove_transfer(/* ... */); } catch (error) { if (error instanceof ProofError) { console.error(\u0026#39;Proof generation failed:\u0026#39;, error.message); } else if (error instanceof DecryptionError) { console.error(\u0026#39;Decryption failed:\u0026#39;, error.message); } } Type Definitions # interface CipherBalance { L: ProjectivePoint; // g^amount * pubkey^randomness R: ProjectivePoint; // g^randomness } interface ProofOfOwnership { A: ProjectivePoint; // Commitment s: bigint; // Response } interface ProofOfRange { commitments: ProjectivePoint[]; // Bit commitments responses: ProofOfOwnership[]; // OR proofs for each bit challenge: bigint; // Fiat-Shamir challenge } interface ExPostProof { ownership: ProofOfOwnership; // Proof of sender key consistency: ProofOfOwnership; // Proof of amount consistency senderCipher: CipherBalance; // New sender encryption disclosureCipher: CipherBalance; // Disclosure party encryption } The SHE library provides the cryptographic foundation for all Tongo operations, implementing state-of-the-art zero-knowledge proofs with efficient elliptic curve arithmetic.\n"}]